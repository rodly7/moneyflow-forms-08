import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface UnifiedTransaction {
  id: string;
  type: string;
  amount: number;
  date: Date;
  description: string;
  currency: string;
  status: string;
  verification_code?: string;
  created_at: string;
  withdrawal_phone?: string;
  recipient_full_name?: string;
  recipient_phone?: string;
  fees?: number;
  userType: "agent" | "user";
  impact: "credit" | "debit";
  sender_name?: string;
  reference_id?: string;
  payment_method?: string;
  payment_phone?: string;
}

export const useAllTransactions = (userId?: string) => {
  const [transactions, setTransactions] = useState<UnifiedTransaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchAllTransactions = async () => {
    if (!userId) {
      console.log("‚ùå DEBUG: Pas d'ID utilisateur fourni");
      setTransactions([]);
      setLoading(false);
      return;
    }

    try {
      console.log("üîç DEBUG: R√©cup√©ration compl√®te des transactions pour userId:", userId);
      setLoading(true);
      setError(null);

      const allTransactions: UnifiedTransaction[] = [];

      // 1. R√©cup√©rer les recharges (CR√âDIT) - DEBUG D√âTAILL√â
      console.log("üí≥ DEBUG: D√©but r√©cup√©ration des recharges...");
      
      const rechargesQuery = supabase
        .from('recharges')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      
      console.log("üí≥ DEBUG: Requ√™te recharges construite pour user_id:", userId);
      
      const { data: rechargesData, error: rechargesError } = await rechargesQuery;

      console.log("üí≥ DEBUG: R√©sultat requ√™te recharges:");
      console.log("üí≥ DEBUG: - Erreur:", rechargesError);
      console.log("üí≥ DEBUG: - Donn√©es brutes:", rechargesData);
      console.log("üí≥ DEBUG: - Nombre de recharges trouv√©es:", rechargesData?.length || 0);

      if (rechargesError) {
        console.error('‚ùå DEBUG: Erreur d√©taill√©e recharges:', {
          message: rechargesError.message,
          details: rechargesError.details,
          hint: rechargesError.hint,
          code: rechargesError.code
        });
      } else if (rechargesData && rechargesData.length > 0) {
        console.log("‚úÖ DEBUG: Traitement de", rechargesData.length, "recharges");
        rechargesData.forEach((recharge, index) => {
          console.log(`üí≥ DEBUG: Recharge ${index + 1}:`, {
            id: recharge.id,
            amount: recharge.amount,
            status: recharge.status,
            created_at: recharge.created_at,
            user_id: recharge.user_id,
            payment_method: recharge.payment_method
          });
          
          allTransactions.push({
            id: `recharge_${recharge.id}`,
            type: 'recharge',
            amount: recharge.amount || 0,
            date: new Date(recharge.created_at),
            description: `Recharge de compte via ${recharge.payment_method || 'Mobile Money'}`,
            currency: 'XAF',
            status: recharge.status || 'pending',
            created_at: recharge.created_at,
            userType: "user" as const,
            impact: "credit" as const,
            payment_method: recharge.payment_method,
            payment_phone: recharge.payment_phone,
            reference_id: recharge.id?.toString()
          });
        });
      } else {
        console.log("‚ö†Ô∏è DEBUG: Aucune recharge trouv√©e pour l'utilisateur");
      }

      // 2. R√©cup√©rer les retraits (D√âBIT) - DEBUG D√âTAILL√â
      console.log("üèß DEBUG: D√©but r√©cup√©ration des retraits...");
      
      const withdrawalsQuery = supabase
        .from('withdrawals')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
        
      console.log("üèß DEBUG: Requ√™te retraits construite pour user_id:", userId);
      
      const { data: withdrawalsData, error: withdrawalsError } = await withdrawalsQuery;

      console.log("üèß DEBUG: R√©sultat requ√™te retraits:");
      console.log("üèß DEBUG: - Erreur:", withdrawalsError);
      console.log("üèß DEBUG: - Donn√©es brutes:", withdrawalsData);
      console.log("üèß DEBUG: - Nombre de retraits trouv√©s:", withdrawalsData?.length || 0);

      if (withdrawalsError) {
        console.error('‚ùå DEBUG: Erreur d√©taill√©e retraits:', {
          message: withdrawalsError.message,
          details: withdrawalsError.details,
          hint: withdrawalsError.hint,
          code: withdrawalsError.code
        });
      } else if (withdrawalsData && withdrawalsData.length > 0) {
        console.log("‚úÖ DEBUG: Traitement de", withdrawalsData.length, "retraits");
        withdrawalsData.forEach((withdrawal, index) => {
          console.log(`üèß DEBUG: Retrait ${index + 1}:`, {
            id: withdrawal.id,
            amount: withdrawal.amount,
            status: withdrawal.status,
            created_at: withdrawal.created_at,
            user_id: withdrawal.user_id,
            withdrawal_phone: withdrawal.withdrawal_phone
          });
          
          allTransactions.push({
            id: withdrawal.id,
            type: 'withdrawal',
            amount: withdrawal.amount || 0,
            date: new Date(withdrawal.created_at),
            description: `Retrait d'argent vers ${withdrawal.withdrawal_phone || 'N/A'}`,
            currency: 'XAF',
            status: withdrawal.status || 'pending',
            created_at: withdrawal.created_at,
            withdrawal_phone: withdrawal.withdrawal_phone,
            verification_code: withdrawal.verification_code,
            userType: "user" as const,
            impact: "debit" as const,
            reference_id: withdrawal.id
          });
        });
      } else {
        console.log("‚ö†Ô∏è DEBUG: Aucun retrait trouv√© pour l'utilisateur");
      }

      // 3. R√©cup√©rer les transferts envoy√©s (D√âBIT)
      console.log("üì§ R√©cup√©ration des transferts envoy√©s...");
      const { data: sentTransfersData, error: sentTransfersError } = await supabase
        .from('transfers')
        .select('*')
        .eq('sender_id', userId)
        .order('created_at', { ascending: false });

      if (sentTransfersError) {
        console.error('‚ùå Erreur transferts envoy√©s:', sentTransfersError);
      } else if (sentTransfersData) {
        console.log("‚úÖ Transferts envoy√©s trouv√©s:", sentTransfersData.length);
        sentTransfersData.forEach(transfer => {
          allTransactions.push({
            id: transfer.id,
            type: 'transfer_sent',
            amount: transfer.amount || 0,
            date: new Date(transfer.created_at),
            description: `Transfert envoy√© vers ${transfer.recipient_full_name || transfer.recipient_phone}`,
            currency: 'XAF',
            status: transfer.status || 'pending',
            created_at: transfer.created_at,
            recipient_full_name: transfer.recipient_full_name,
            recipient_phone: transfer.recipient_phone,
            fees: transfer.fees,
            userType: "user" as const,
            impact: "debit" as const,
            reference_id: transfer.id
          });
        });
      }

      // 4. R√©cup√©rer les transferts re√ßus (CR√âDIT)
      console.log("üì• R√©cup√©ration des transferts re√ßus...");
      const { data: userProfile, error: profileError } = await supabase
        .from('profiles')
        .select('phone')
        .eq('id', userId)
        .single();

      if (userProfile?.phone) {
        // DEBUG: Afficher le t√©l√©phone de l'utilisateur
        console.log("üìû DEBUG: T√©l√©phone utilisateur pour recherche transferts re√ßus:", userProfile.phone);
        
        // Utiliser la fonction RPC s√©curis√©e pour contourner les limitations RLS et avoir le nom de l'exp√©diteur
        console.log("üì• DEBUG: R√©cup√©ration transferts re√ßus via RPC...");
        const { data: receivedRpc, error: receivedRpcError } = await supabase
          .rpc('get_received_transfers_with_sender', { p_user_id: userId } as any);

        console.log("üì• DEBUG: R√©sultat RPC transferts re√ßus:");
        console.log("üì• DEBUG: - Erreur:", receivedRpcError);
        console.log("üì• DEBUG: - Donn√©es brutes:", receivedRpc);
        console.log("üì• DEBUG: - Nombre de transferts re√ßus:", receivedRpc?.length || 0);

        if (receivedRpcError) {
          console.error('‚ùå DEBUG: Erreur transferts re√ßus (RPC):', receivedRpcError);
        } else if (receivedRpc && receivedRpc.length > 0) {
          console.log("‚úÖ DEBUG: Transferts re√ßus (RPC):", receivedRpc.length);
          receivedRpc.forEach((row: any, index: number) => {
            const senderName = row.sender_full_name || row.sender_phone || 'Exp√©diteur inconnu';
            console.log(`üì• DEBUG: Transfert re√ßu ${index + 1}:`, {
              id: row.id,
              amount: row.amount,
              status: row.status,
              created_at: row.created_at,
              sender_name: senderName
            });
            
            allTransactions.push({
              id: `received_${row.id}`,
              type: 'transfer_received',
              amount: Number(row.amount) || 0,
              date: new Date(row.created_at),
              description: `Transfert re√ßu de ${senderName}`,
              currency: 'XAF',
              status: row.status || 'completed',
              created_at: row.created_at,
              sender_name: senderName,
              userType: 'user' as const,
              impact: 'credit' as const,
              reference_id: row.id
            });
          });
        } else {
          console.log("‚ö†Ô∏è DEBUG: Aucun transfert re√ßu trouv√© via RPC");
        }
      } else {
        console.log("‚ö†Ô∏è DEBUG: Pas de t√©l√©phone trouv√© pour l'utilisateur - impossible de rechercher les transferts re√ßus");
      }

      // 5. R√©cup√©rer les paiements de factures automatiques (D√âBIT)
      console.log("üìÑ R√©cup√©ration des paiements de factures automatiques...");
      const { data: billPaymentsData, error: billPaymentsError } = await supabase
        .from('bill_payment_history')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

      if (billPaymentsError) {
        console.error('‚ùå Erreur paiements factures:', billPaymentsError);
      } else if (billPaymentsData) {
        console.log("‚úÖ Paiements de factures trouv√©s:", billPaymentsData.length);
        billPaymentsData.forEach(payment => {
          allTransactions.push({
            id: `bill_${payment.id}`,
            type: 'bill_payment',
            amount: payment.amount || 0,
            date: new Date(payment.created_at || payment.payment_date),
            description: `Paiement de facture`,
            currency: 'XAF',
            status: payment.status || 'completed',
            created_at: payment.created_at || payment.payment_date,
            userType: "user" as const,
            impact: "debit" as const,
            reference_id: payment.id?.toString()
          });
        });
      }


      // 6. R√©cup√©rer les transferts en attente (D√âBIT)
      console.log("‚è≥ R√©cup√©ration des transferts en attente...");
      const { data: pendingTransfers, error: pendingError } = await supabase
        .from('pending_transfers')
        .select('*')
        .eq('sender_id', userId)
        .order('created_at', { ascending: false });

      if (pendingError) {
        console.error("‚ùå Erreur transferts en attente:", pendingError);
      } else if (pendingTransfers) {
        console.log("‚úÖ Transferts en attente trouv√©s:", pendingTransfers.length);
        pendingTransfers.forEach(pending => {
          allTransactions.push({
            id: `pending_${pending.id}`,
            type: 'transfer_pending',
            amount: pending.amount || 0,
            date: new Date(pending.created_at),
            description: `Transfert en attente vers ${pending.recipient_phone}`,
            currency: 'XAF',
            status: 'pending',
            created_at: pending.created_at,
            verification_code: pending.claim_code,
            userType: "user" as const,
            impact: "debit" as const,
            fees: pending.fees || 0,
            reference_id: pending.id?.toString()
          });
        });
      }

      // 7. R√©cup√©rer les paiements par scanner/QR (D√âBIT)
      console.log("üì± R√©cup√©ration des paiements par scanner...");
      const { data: merchantPayments, error: merchantError } = await supabase
        .from('merchant_payments')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

      if (merchantError) {
        console.error("‚ùå Erreur paiements scanner:", merchantError);
      } else if (merchantPayments) {
        console.log("‚úÖ Paiements par scanner trouv√©s:", merchantPayments.length);
        merchantPayments.forEach(payment => {
          allTransactions.push({
            id: `merchant_${payment.id}`,
            type: 'merchant_payment',
            amount: payment.amount || 0,
            date: new Date(payment.created_at),
            description: `Paiement par scanner de ${payment.amount?.toLocaleString() || '0'} XAF √† ${payment.business_name}`,
            currency: payment.currency || 'XAF',
            status: payment.status || 'completed',
            created_at: payment.created_at,
            userType: "user" as const,
            impact: "debit" as const,
            reference_id: payment.id?.toString()
          });
        });
      }

      // Trier par date d√©croissante (plus r√©centes en premier)
      const sortedTransactions = allTransactions.sort((a, b) => 
        new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      );

      console.log("üìä DEBUG: R√©sum√© final des transactions:");
      console.log("üìä DEBUG: - Total transactions:", sortedTransactions.length);
      console.log("üìä DEBUG: - Recharges:", sortedTransactions.filter(t => t.type === 'recharge').length);
      console.log("üìä DEBUG: - Retraits:", sortedTransactions.filter(t => t.type === 'withdrawal').length);
      console.log("üìä DEBUG: - Transferts envoy√©s:", sortedTransactions.filter(t => t.type === 'transfer_sent').length);
      console.log("üìä DEBUG: - Transferts re√ßus:", sortedTransactions.filter(t => t.type === 'transfer_received').length);
      console.log("üìä DEBUG: - Paiements factures:", sortedTransactions.filter(t => t.type === 'bill_payment').length);
      console.log("üìä DEBUG: - En attente:", sortedTransactions.filter(t => t.type === 'transfer_pending').length);
      console.log("üìä DEBUG: - Paiements scanner:", sortedTransactions.filter(t => t.type === 'merchant_payment').length);

      // Afficher les 3 premi√®res transactions pour debug
      console.log("üìã DEBUG: Les 3 premi√®res transactions:", sortedTransactions.slice(0, 3).map(t => ({
        id: t.id,
        type: t.type,
        amount: t.amount,
        description: t.description,
        date: t.date,
        impact: t.impact
      })));

      // Afficher sp√©cifiquement les transferts re√ßus pour debug
      const receivedTransfers = sortedTransactions.filter(t => t.type === 'transfer_received');
      console.log("üí∞ DEBUG: D√©tail des transferts re√ßus:", receivedTransfers.map(t => ({
        id: t.id,
        amount: t.amount,
        description: t.description,
        sender_name: t.sender_name,
        created_at: t.created_at
      })));

      setTransactions(sortedTransactions);
    } catch (error) {
      console.error("‚ùå DEBUG: Erreur g√©n√©rale lors de la r√©cup√©ration des transactions:", error);
      setError("Erreur lors du chargement des transactions");
      setTransactions([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!userId) {
      console.log("‚ö†Ô∏è DEBUG: Pas de userId, arr√™t du loading");
      setLoading(false);
      setTransactions([]);
      return;
    }

    console.log("üöÄ DEBUG: D√©marrage fetchAllTransactions pour userId:", userId);
    fetchAllTransactions();

    // √âcouter les mises √† jour d√©clench√©es par l'app (ex: apr√®s une action r√©ussie)
    const handleTransactionUpdate = () => {
      fetchAllTransactions();
    };
    window.addEventListener('transactionUpdate', handleTransactionUpdate);

    // Realtime: r√©-actualiser automatiquement la liste quand une transaction change
    const triggerRefetch = () => {
      console.log('üîÑ Realtime: mise √† jour d√©tect√©e, actualisation des transactions');
      fetchAllTransactions();
    };

    const channel = supabase.channel(`tx_${userId}`);
    channel
      .on('postgres_changes', { event: '*', schema: 'public', table: 'withdrawals', filter: `user_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'recharges', filter: `user_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'pending_transfers', filter: `sender_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'transfers', filter: `sender_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'merchant_payments', filter: `user_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'bill_payment_history', filter: `user_id=eq.${userId}` }, triggerRefetch)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'notifications', filter: `target_users=cs.{${userId}}` }, triggerRefetch)
      .subscribe();

    // √âcouter aussi les transferts re√ßus par t√©l√©phone
    let phoneChannel: any;
    (async () => {
      const { data: profile } = await supabase
        .from('profiles')
        .select('phone')
        .eq('id', userId)
        .maybeSingle();

      if (profile?.phone) {
        phoneChannel = supabase.channel(`tx_phone_${profile.phone}`);
        phoneChannel
          .on('postgres_changes', { event: '*', schema: 'public', table: 'transfers', filter: `recipient_phone=eq.${profile.phone}` }, triggerRefetch)
          .subscribe();
      }
    })();

    return () => {
      window.removeEventListener('transactionUpdate', handleTransactionUpdate);
      if (phoneChannel) supabase.removeChannel(phoneChannel);
      supabase.removeChannel(channel);
    };
  }, [userId]);

  return {
    transactions,
    loading,
    error,
    refetch: fetchAllTransactions
  };
};
